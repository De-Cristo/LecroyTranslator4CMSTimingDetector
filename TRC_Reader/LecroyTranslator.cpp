// % ReadLeCroyBinaryWaveform -  read binary waveform file created by a LeCroy Oscilloscope
// %     waveform = LeCroyBinaryWaveform(FILENAME) loads the waveform file into the workspace variable W.
// %     FILENAME can either be a variable or a string constant enclosed by quotes.
// %
// %     The return value "waveform" is a record containing four elements:
// %     waveform.INFO   Waveform information, in readable formats. For example Oscilloscope ID, sampling time and settings
// %     waveform.DESC   Waveform information used for further calculations. For example Sampling rate
// %     waveform.Y      Values sampled by the oscilloscope
// %     waveform.X      Array of time values corresponding to waveform.Y. Time '0' marks the trigger event
// %
// %     The routine was tested with files generated by a WavePro7300 and WaveRunner64Xi, Template LECROY_2_3
// %
// % See also LCPLOT LCPLOTEXT
// %
// %------------------------------------------------------
// % Original version (c)2001 Hochschule fï¿½r Technik+Architektur Luzern
// % Fachstelle Elektronik
// % 6048 Horw, Switzerland
// % Slightly modified by Alan Blankman, LeCroy Corporation, 2006
// % July 2007; added decoding of TrigTime_array so that sequence mode waveforms decode correctly
// % Slightly modified by Jean-Daniel Deschênes, Universite Laval, 2010
// % Added support for sequence mode, even if RECORD_TYPE says "single_sweep"
// % (seen on a WavePro 7 Zi).  Output will be a MxN matrix, where M is the
// % number of points in each segment, and N is the number of segments.  X
// % vector also update to include offset of each trigger.

// modified into cpp format by Licheng ZHANG (licheng.zhang@cern.ch) on 04/12/2025

// ReadLeCroyBinaryWaveform.cpp
// C++ reader for LeCroy waveform files (template LECROY_2_3)
// Produces:
//   <basename>_data.csv : Segment,Time_s,Voltage_V
//   <basename>_meta.csv : Field,Value
//
// Compile (example):
//   g++ -std=c++17 -O2 ReadLeCroyBinaryWaveform.cpp -o read_lecroy
//
// Run:
//   ./read_lecroy mywave.trc

// 

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdint>
#include <cstring>
#include <cmath>
#include <stdexcept>
#include <iomanip>
#include <sstream>
#include <filesystem>

// -------------------------------------------------------------
// Utility: byte-order helpers
// -------------------------------------------------------------
template<typename T>
T readScalar(const std::vector<uint8_t>& buf, std::size_t offset, bool littleEndian)
{
    if (offset + sizeof(T) > buf.size())
        throw std::runtime_error("readScalar: offset out of range");

    T value{};
    if (littleEndian) {
        // File is little-endian: copy as-is on x86
        std::memcpy(&value, buf.data() + offset, sizeof(T));
    } else {
        // File is big-endian: reverse bytes into value
        uint8_t tmp[sizeof(T)];
        for (std::size_t i = 0; i < sizeof(T); ++i) {
            tmp[i] = buf[offset + sizeof(T) - 1 - i];
        }
        std::memcpy(&value, tmp, sizeof(T));
    }
    return value;
}

// read raw bytes as string (up to len, no null-termination guaranteed)
std::string readString(const std::vector<uint8_t>& buf, std::size_t offset, std::size_t len)
{
    if (offset + len > buf.size())
        throw std::runtime_error("readString: offset out of range");
    std::string s(reinterpret_cast<const char*>(buf.data() + offset), len);
    // trim trailing nulls and spaces
    std::size_t end = s.find_last_not_of(" \0", std::string::npos);
    if (end == std::string::npos) return "";
    return s.substr(0, end + 1);
}

// -------------------------------------------------------------
// Data structures
// -------------------------------------------------------------
struct WaveInfo {
    std::string instrumentName;
    int32_t     instrumentNumber = 0;
    std::string fileName;

    std::string triggerTimeString;  // simple formatted string
    std::string waveSource;
    std::string vertCoupling;
    std::string bandwidthLimit;
    std::string recordType;
    std::string processingDone;

    int16_t     nominalBits   = 0;
    int32_t     nbSegments    = 0;  // SUBARRAY_COUNT
};

struct WaveDesc {
    double Ts = 0.0;  // sampling interval
    double fs = 0.0;  // sampling rate
};

struct Waveform {
    WaveInfo info;
    WaveDesc desc;

    // For single-sweep: x[0] and y[0] hold the whole trace
    // For sequence mode: x[seg], y[seg] per segment
    std::vector<std::vector<double>> x;
    std::vector<std::vector<double>> y;

    // For sequence mode
    std::vector<double> trigger_time;   // length nbSegments
    std::vector<double> trigger_offset; // length nbSegments
};

// -------------------------------------------------------------
// Helper: format timestamp like MATLAB version (simplified)
// -------------------------------------------------------------
std::string formatTimestamp(double seconds,
                            int8_t minutes,
                            int8_t hours,
                            int8_t days,
                            int8_t months,
                            int16_t year)
{
    char buf[128];
    std::snprintf(buf, sizeof(buf),
                  "%d.%d.%d, %d:%d:%02.0f",
                  static_cast<int>(days),
                  static_cast<int>(months),
                  static_cast<int>(year),
                  static_cast<int>(hours),
                  static_cast<int>(minutes),
                  seconds);
    return std::string(buf);
}

// simple numeric->string with high precision
template<typename T>
std::string toStringPrec(T v, int prec = 15)
{
    std::ostringstream oss;
    oss << std::setprecision(prec) << v;
    return oss.str();
}

// format a vector<double> as "[v0;v1;v2;...]" (MATLAB column vector style)
std::string toVectorString(const std::vector<double>& v, int prec = 15)
{
    std::ostringstream oss;
    oss << "[";
    for (std::size_t i = 0; i < v.size(); ++i) {
        if (i > 0) oss << ";";
        oss << std::setprecision(prec) << v[i];
    }
    oss << "]";
    return oss.str();
}



// -------------------------------------------------------------
// Main reader function
// -------------------------------------------------------------
Waveform ReadLeCroyBinaryWaveform(const std::string& filename)
{
    Waveform wave;

    // -------------------- read whole file into memory --------------------
    std::ifstream fin(filename, std::ios::binary);
    if (!fin) {
        throw std::runtime_error("Cannot open file: " + filename);
    }
    fin.seekg(0, std::ios::end);
    std::size_t fileSize = static_cast<std::size_t>(fin.tellg());
    fin.seekg(0, std::ios::beg);

    std::vector<uint8_t> buf(fileSize);
    fin.read(reinterpret_cast<char*>(buf.data()), fileSize);
    fin.close();

    wave.info.fileName = filename;

    // -------------------- find "WAVEDESC" in first 50 bytes --------------------
    std::size_t WAVEDESC = std::string::npos;
    const char key[] = "WAVEDESC";
    for (std::size_t i = 0; i + 8 <= 50 && i + 8 <= fileSize; ++i) {
        if (std::memcmp(buf.data() + i, key, 8) == 0) {
            WAVEDESC = i;
            break;
        }
    }
    if (WAVEDESC == std::string::npos) {
        throw std::runtime_error("WAVEDESC not found in header");
    }

    // -------------------- offsets as in MATLAB code --------------------
    const std::size_t aTEMPLATE_NAME   = WAVEDESC + 16;
    const std::size_t aCOMM_TYPE       = WAVEDESC + 32;
    const std::size_t aCOMM_ORDER      = WAVEDESC + 34;
    const std::size_t aWAVE_DESCRIPTOR = WAVEDESC + 36;
    const std::size_t aUSER_TEXT       = WAVEDESC + 40;
    const std::size_t aTRIGTIME_ARRAY  = WAVEDESC + 48;
    const std::size_t aWAVE_ARRAY_1    = WAVEDESC + 60;
    const std::size_t aINSTRUMENT_NAME = WAVEDESC + 76;
    const std::size_t aINSTRUMENT_NUMBER = WAVEDESC + 92;
    const std::size_t aTRACE_LABEL     = WAVEDESC + 96;
    const std::size_t aWAVE_ARRAY_COUNT = WAVEDESC + 116;
    const std::size_t aSUBARRAY_COUNT  = WAVEDESC + 144;
    const std::size_t aVERTICAL_GAIN   = WAVEDESC + 156;
    const std::size_t aVERTICAL_OFFSET = WAVEDESC + 160;
    const std::size_t aNOMINAL_BITS    = WAVEDESC + 172;
    const std::size_t aHORIZ_INTERVAL  = WAVEDESC + 176;
    const std::size_t aHORIZ_OFFSET    = WAVEDESC + 180;
    const std::size_t aVERTUNIT        = WAVEDESC + 196;
    const std::size_t aHORUNIT         = WAVEDESC + 244;
    const std::size_t aTRIGGER_TIME    = WAVEDESC + 296;
    const std::size_t aRECORD_TYPE     = WAVEDESC + 316;
    const std::size_t aPROCESSING_DONE = WAVEDESC + 318;
    const std::size_t aTIMEBASE        = WAVEDESC + 324;
    const std::size_t aVERT_COUPLING   = WAVEDESC + 326;
    const std::size_t aPROBE_ATT       = WAVEDESC + 328;
    const std::size_t aFIXED_VERT_GAIN = WAVEDESC + 332;
    const std::size_t aBANDWIDTH_LIMIT = WAVEDESC + 334;
    const std::size_t aVERTICAL_VERNIER= WAVEDESC + 336;
    const std::size_t aACQ_VERT_OFFSET = WAVEDESC + 340;
    const std::size_t aWAVE_SOURCE     = WAVEDESC + 344;

    // -------------------- determine COMM_ORDER (endianness) --------------------
    int16_t comm_order_le = readScalar<int16_t>(buf, aCOMM_ORDER, /*littleEndian=*/true);
    bool fileLittle = true;
    int16_t COMM_ORDER = comm_order_le;
    if (COMM_ORDER != 0 && COMM_ORDER != 1) {
        // maybe file is big-endian
        int16_t comm_order_be = readScalar<int16_t>(buf, aCOMM_ORDER, /*littleEndian=*/false);
        if (comm_order_be == 0 || comm_order_be == 1) {
            COMM_ORDER = comm_order_be;
            fileLittle = false;
        } else {
            throw std::runtime_error("COMM_ORDER is neither 0 nor 1 in LE or BE");
        }
    } else {
        fileLittle = (COMM_ORDER != 0); // COMM_ORDER==0 => big-endian
    }
    bool littleEndian = fileLittle;

    // -------------------- read template name (mainly for warning) --------------------
    std::string templateName = readString(buf, aTEMPLATE_NAME, 16);
    const std::string TESTED_TEMPLATE = "LECROY_2_3";
    if (templateName.find(TESTED_TEMPLATE) == std::string::npos) {
        std::cerr << "WARNING: file template is \"" << templateName
                  << "\" but code was written for \"" << TESTED_TEMPLATE
                  << "\".\n";
    }

    // -------------------- Instrument info --------------------
    wave.info.instrumentName   = readString(buf, aINSTRUMENT_NAME, 16);
    wave.info.instrumentNumber = readScalar<int32_t>(buf, aINSTRUMENT_NUMBER, littleEndian);

    // -------------------- Trigger time (timestamp) --------------------
    {
        std::size_t off = aTRIGGER_TIME;
        double  seconds = readScalar<double>(buf, off + 0,  littleEndian);
        int8_t  minutes = readScalar<int8_t >(buf, off + 8,  littleEndian);
        int8_t  hours   = readScalar<int8_t >(buf, off + 9,  littleEndian);
        int8_t  days    = readScalar<int8_t >(buf, off + 10, littleEndian);
        int8_t  months  = readScalar<int8_t >(buf, off + 11, littleEndian);
        int16_t year    = readScalar<int16_t>(buf, off + 12, littleEndian);

        wave.info.triggerTimeString = formatTimestamp(seconds, minutes,
                                                      hours, days, months, year);
    }

    // -------------------- Wave source, coupling, bandwidth, record type, processing --------------------
    {
        static const char* sources[] = {
            "channel 1", "channel 2", "channel 3", "channel 4", "unknown"
        };
        int16_t idx = readScalar<int16_t>(buf, aWAVE_SOURCE, littleEndian);
        int sidx = std::max(0, std::min(4, static_cast<int>(idx)));
        wave.info.waveSource = sources[sidx];
    }

    {
        static const char* coup[] = {
            "DC_50_Ohms", "ground", "DC 1MOhm", "ground", "AC 1MOhm"
        };
        int16_t idx = readScalar<int16_t>(buf, aVERT_COUPLING, littleEndian);
        int cidx = std::max(0, std::min(4, static_cast<int>(idx)));
        wave.info.vertCoupling = coup[cidx];
    }

    {
        static const char* bwl[] = { "off", "on" };
        int16_t idx = readScalar<int16_t>(buf, aBANDWIDTH_LIMIT, littleEndian);
        int bidx = (idx == 0 ? 0 : 1);
        wave.info.bandwidthLimit = bwl[bidx];
    }

    {
        static const char* rectypes[] = {
            "single_sweep", "interleaved", "histogram", "graph",
            "filter_coefficient", "complex", "extrema", "sequence_obsolete",
            "centered_RIS", "peak_detect"
        };
        int16_t idx = readScalar<int16_t>(buf, aRECORD_TYPE, littleEndian);
        int ridx = std::max(0, std::min(9, static_cast<int>(idx)));
        wave.info.recordType = rectypes[ridx];
    }

    {
        static const char* proc[] = {
            "no_processing","fir_filter","interpolated","sparsed",
            "autoscaled","no_result","rolling","cumulative"
        };
        int16_t idx = readScalar<int16_t>(buf, aPROCESSING_DONE, littleEndian);
        int pidx = std::max(0, std::min(7, static_cast<int>(idx)));
        wave.info.processingDone = proc[pidx];
    }

    // -------------------- Vertical settings --------------------
    auto readFixedVertGain = [&](std::size_t addr) -> double {
        int16_t e = readScalar<int16_t>(buf, addr, littleEndian);
        int mantIndex = 1 + (e % 3);
        if (mantIndex < 1) mantIndex = 1;
        if (mantIndex > 3) mantIndex = 3;
        double mantArr[3] = {1.0, 2.0, 5.0};
        double mant = mantArr[mantIndex - 1];
        int ex = static_cast<int>(std::floor(e / 3.0)) - 6;
        return mant * std::pow(10.0, ex);
    };

    double FIXED_VERT_GAIN = readFixedVertGain(aFIXED_VERT_GAIN);
    double PROBE_ATT       = readScalar<float>(buf, aPROBE_ATT, littleEndian);
    double VERTICAL_GAIN   = readScalar<float>(buf, aVERTICAL_GAIN, littleEndian);
    double VERTICAL_OFFSET = readScalar<float>(buf, aVERTICAL_OFFSET, littleEndian);
    wave.info.nominalBits  = readScalar<int16_t>(buf, aNOMINAL_BITS, littleEndian);

    // -------------------- Horizontal settings --------------------
    double HORIZ_INTERVAL = readScalar<float>(buf, aHORIZ_INTERVAL, littleEndian);
    double HORIZ_OFFSET   = readScalar<double>(buf, aHORIZ_OFFSET, littleEndian);

    wave.desc.Ts = HORIZ_INTERVAL;
    wave.desc.fs = (HORIZ_INTERVAL != 0.0) ? 1.0 / HORIZ_INTERVAL : 0.0;

    // -------------------- Read COMM_TYPE, descriptor lengths, counts --------------------
    int16_t COMM_TYPE        = readScalar<int16_t>(buf, aCOMM_TYPE, littleEndian);
    int32_t WAVE_DESCRIPTOR  = readScalar<int32_t>(buf, aWAVE_DESCRIPTOR, littleEndian);
    int32_t USER_TEXT        = readScalar<int32_t>(buf, aUSER_TEXT, littleEndian);
    int32_t WAVE_ARRAY_1     = readScalar<int32_t>(buf, aWAVE_ARRAY_1, littleEndian);
    int32_t WAVE_ARRAY_COUNT = readScalar<int32_t>(buf, aWAVE_ARRAY_COUNT, littleEndian);
    int32_t TRIGTIME_ARRAY   = readScalar<int32_t>(buf, aTRIGTIME_ARRAY, littleEndian);
    wave.info.nbSegments     = readScalar<int32_t>(buf, aSUBARRAY_COUNT, littleEndian);

    int32_t nbSegments = wave.info.nbSegments;

    // -------------------- Sequence mode vs single sweep --------------------
    if (nbSegments > 1) {
        // Sequence mode
        std::size_t base = WAVEDESC + WAVE_DESCRIPTOR + USER_TEXT;

        // --- read trigtime array: interleaved TRIGGER_TIME(double), TRIGGER_OFFSET(double) ---
        std::vector<double> tmp(2 * nbSegments);
        for (int i = 0; i < 2 * nbSegments; ++i) {
            tmp[i] = readScalar<double>(buf, base + i * sizeof(double), littleEndian);
        }
        wave.trigger_time.resize(nbSegments);
        wave.trigger_offset.resize(nbSegments);
        for (int i = 0; i < nbSegments; ++i) {
            wave.trigger_time[i]   = tmp[2 * i + 0];
            wave.trigger_offset[i] = tmp[2 * i + 1];
        }

        // --- read ADC values ---
        std::size_t dataStart = WAVEDESC + WAVE_DESCRIPTOR + USER_TEXT + TRIGTIME_ARRAY;

        int32_t pointsPerSegment = WAVE_ARRAY_COUNT / nbSegments;
        if (pointsPerSegment <= 0)
            throw std::runtime_error("Invalid pointsPerSegment in sequence mode");

        wave.x.assign(nbSegments, std::vector<double>(pointsPerSegment));
        wave.y.assign(nbSegments, std::vector<double>(pointsPerSegment));

        for (int seg = 0; seg < nbSegments; ++seg) {
            for (int i = 0; i < pointsPerSegment; ++i) {
                std::size_t idx = dataStart;
                if (COMM_TYPE == 0) { // int8
                    idx += (seg * pointsPerSegment + i) * sizeof(int8_t);
                    int8_t raw = readScalar<int8_t>(buf, idx, littleEndian);
                    double yval = VERTICAL_GAIN * static_cast<double>(raw) - VERTICAL_OFFSET;
                    wave.y[seg][i] = yval;
                } else { // int16
                    idx += (seg * pointsPerSegment + i) * sizeof(int16_t);
                    int16_t raw = readScalar<int16_t>(buf, idx, littleEndian);
                    double yval = VERTICAL_GAIN * static_cast<double>(raw) - VERTICAL_OFFSET;
                    wave.y[seg][i] = yval;
                }

                // time: trigger_time(seg) + (i * HORIZ_INTERVAL + HORIZ_OFFSET)
                wave.x[seg][i] =
                    wave.trigger_time[seg] + (static_cast<double>(i) * HORIZ_INTERVAL + HORIZ_OFFSET);
            }
        }

    } else {
        // Single sweep (or nbSegments == 0 interpreted as 1)
        if (nbSegments <= 0) nbSegments = 1;
        wave.info.nbSegments = nbSegments;

        std::size_t dataStart = WAVEDESC + WAVE_DESCRIPTOR + USER_TEXT + TRIGTIME_ARRAY;

        int32_t nPoints = WAVE_ARRAY_COUNT;  // number of points

        if (nPoints <= 0)
            throw std::runtime_error("No data points in single sweep");

        wave.x.assign(1, std::vector<double>(nPoints));
        wave.y.assign(1, std::vector<double>(nPoints));

        for (int i = 0; i < nPoints; ++i) {
            std::size_t idx = dataStart;
            if (COMM_TYPE == 0) { // int8
                idx += i * sizeof(int8_t);
                int8_t raw = readScalar<int8_t>(buf, idx, littleEndian);
                double yval = VERTICAL_GAIN * static_cast<double>(raw) - VERTICAL_OFFSET;
                wave.y[0][i] = yval;
            } else { // int16
                idx += i * sizeof(int16_t);
                int16_t raw = readScalar<int16_t>(buf, idx, littleEndian);
                double yval = VERTICAL_GAIN * static_cast<double>(raw) - VERTICAL_OFFSET;
                wave.y[0][i] = yval;
            }

            wave.x[0][i] = static_cast<double>(i) * HORIZ_INTERVAL + HORIZ_OFFSET;
        }
    }

    return wave;
}

// -------------------------------------------------------------
// CSV writer: flatten segments into "Segment,Time_s,Voltage_V"
// -------------------------------------------------------------
void writeDataCSV(const Waveform& wave, const std::string& inputFile)
{
    namespace fs = std::filesystem;

    fs::path inPath(inputFile);
    std::string base = inPath.stem().string();  // file name without extension
    std::string outName = base + "_data.csv";

    std::ofstream fout(outName);
    if (!fout) {
        throw std::runtime_error("Cannot open CSV file for writing: " + outName);
    }

    // header
    fout << "Segment,Time_s,Voltage_V\n";
    fout << std::setprecision(15);

    int nSeg = static_cast<int>(wave.x.size());
    for (int seg = 0; seg < nSeg; ++seg) {
        const auto& tx = wave.x[seg];
        const auto& ty = wave.y[seg];
        if (tx.size() != ty.size()) {
            throw std::runtime_error("Inconsistent x/y sizes in segment " + std::to_string(seg));
        }
        for (std::size_t i = 0; i < tx.size(); ++i) {
            fout << seg+1 << "," << tx[i] << "," << ty[i] << "\n";
        }
    }

    fout.close();
    std::cout << "Data CSV written to: " << outName << "\n";
}

// -------------------------------------------------------------
// Meta CSV writer: "Field,Value", similar spirit to MATLAB version
// -------------------------------------------------------------
void writeMetaCSV(const Waveform& wave, const std::string& inputFile)
{
    namespace fs = std::filesystem;

    fs::path inPath(inputFile);
    std::string base = inPath.stem().string();  // file name without extension
    std::string outName = base + "_meta.csv";

    std::ofstream fout(outName);
    if (!fout) {
        throw std::runtime_error("Cannot open meta CSV file for writing: " + outName);
    }

    fout << "Field,Value\n";

    // info.*
    fout << "info.instrumentName,"   << wave.info.instrumentName   << "\n";
    fout << "info.instrumentNumber," << wave.info.instrumentNumber << "\n";
    fout << "info.fileName,"         << wave.info.fileName         << "\n";
    fout << "info.triggerTimeString,"<< wave.info.triggerTimeString<< "\n";
    fout << "info.waveSource,"       << wave.info.waveSource       << "\n";
    fout << "info.vertCoupling,"     << wave.info.vertCoupling     << "\n";
    fout << "info.bandwidthLimit,"   << wave.info.bandwidthLimit   << "\n";
    fout << "info.recordType,"       << wave.info.recordType       << "\n";
    fout << "info.processingDone,"   << wave.info.processingDone   << "\n";
    fout << "info.nominalBits,"      << wave.info.nominalBits      << "\n";
    fout << "info.nbSegments,"       << wave.info.nbSegments       << "\n";

    // desc.*
    fout << "desc.Ts," << toStringPrec(wave.desc.Ts) << "\n";
    fout << "desc.fs," << toStringPrec(wave.desc.fs) << "\n";

    // Some extras: number of points per segment
    if (!wave.x.empty()) {
        fout << "desc.pointsPerSegment," << wave.x[0].size() << "\n";
    }

    // --- NEW: top-level trigger_time and trigger_offset (sequence mode) ---
    // These correspond to MATLAB's wave.trigger_time and wave.trigger_offset
    if (!wave.trigger_time.empty()) {
        fout << "trigger_time," << toVectorString(wave.trigger_time) << "\n";
    }
    if (!wave.trigger_offset.empty()) {
        fout << "trigger_offset," << toVectorString(wave.trigger_offset) << "\n";
    }

    fout.close();
    std::cout << "Meta CSV written to: " << outName << "\n";
}


// -------------------------------------------------------------
// main() to test / demonstrate usage
// -------------------------------------------------------------
int main(int argc, char* argv[])
{
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " waveform.trc\n";
        return 1;
    }

    try {
        Waveform wave = ReadLeCroyBinaryWaveform(argv[1]);

        std::cout << "File: " << wave.info.fileName << "\n";
        std::cout << "Instrument: " << wave.info.instrumentName
                  << " #" << wave.info.instrumentNumber << "\n";
        std::cout << "Trigger time: " << wave.info.triggerTimeString << "\n";
        std::cout << "Source: " << wave.info.waveSource << "\n";
        std::cout << "Record type: " << wave.info.recordType << "\n";
        std::cout << "nbSegments: " << wave.info.nbSegments << "\n";
        std::cout << "Ts = " << wave.desc.Ts << " s, fs = " << wave.desc.fs << " Hz\n";

        if (!wave.x.empty()) {
            std::cout << "Segment 0 has " << wave.x[0].size() << " points.\n";
            if (!wave.x[0].empty()) {
                std::cout << "First sample: t=" << wave.x[0][0]
                          << " s, V=" << wave.y[0][0] << " V\n";
            }
        }

        // Write CSV files
        writeDataCSV(wave, wave.info.fileName);
        writeMetaCSV(wave, wave.info.fileName);

    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << "\n";
        return 2;
    }

    return 0;
}
